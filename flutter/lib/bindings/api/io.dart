// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'patch.dart';

// These functions are ignored because they are not marked as `pub`: `new`, `run_juce_message_loop`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `AudioMessage`, `PatchAudioCallback`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `about_to_start`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `process_block`, `stopped`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioManager>>
abstract class AudioManager implements RustOpaqueInterface {
  Future<void> clearPatch();

  Future<String?> getDeviceType();

  Future<List<String>> getDeviceTypes();

  Future<List<String>> getInputDevices({required String deviceType});

  Future<List<String>> getMidiInputDevices();

  Future<List<String>> getMidiOutputDevices();

  Future<FlutterMidiConfiguration> getMidiSetup();

  Future<List<String>> getOutputDevices({required String deviceType});

  Future<AudioConfiguration> getSetup();

  factory AudioManager() => RustLib.instance.api.crateApiIoAudioManagerNew();

  Future<void> setDeviceType({required String deviceType});

  Future<void> setMidiSetup({required FlutterMidiConfiguration config});

  Future<void> setPatch({required Patch patch});

  Future<void> setSetup({required AudioConfiguration config});

  Future<void> shutdown();

  Future<void> stopPlayback();
}

class AudioConfiguration {
  final String inputDevice;
  final String outputDevice;
  final double sampleRate;
  final BigInt bufferSize;

  const AudioConfiguration({
    required this.inputDevice,
    required this.outputDevice,
    required this.sampleRate,
    required this.bufferSize,
  });

  static Future<AudioConfiguration> default_() =>
      RustLib.instance.api.crateApiIoAudioConfigurationDefault();

  @override
  int get hashCode =>
      inputDevice.hashCode ^
      outputDevice.hashCode ^
      sampleRate.hashCode ^
      bufferSize.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioConfiguration &&
          runtimeType == other.runtimeType &&
          inputDevice == other.inputDevice &&
          outputDevice == other.outputDevice &&
          sampleRate == other.sampleRate &&
          bufferSize == other.bufferSize;
}

class FlutterMidiConfiguration {
  final String inputDevice;
  final String outputDevice;
  final bool enabled;
  final bool clockEnabled;
  final bool transportEnabled;
  final bool programChangeEnabled;

  const FlutterMidiConfiguration({
    required this.inputDevice,
    required this.outputDevice,
    required this.enabled,
    required this.clockEnabled,
    required this.transportEnabled,
    required this.programChangeEnabled,
  });

  static Future<FlutterMidiConfiguration> default_() =>
      RustLib.instance.api.crateApiIoFlutterMidiConfigurationDefault();

  @override
  int get hashCode =>
      inputDevice.hashCode ^
      outputDevice.hashCode ^
      enabled.hashCode ^
      clockEnabled.hashCode ^
      transportEnabled.hashCode ^
      programChangeEnabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterMidiConfiguration &&
          runtimeType == other.runtimeType &&
          inputDevice == other.inputDevice &&
          outputDevice == other.outputDevice &&
          enabled == other.enabled &&
          clockEnabled == other.clockEnabled &&
          transportEnabled == other.transportEnabled &&
          programChangeEnabled == other.programChangeEnabled;
}
