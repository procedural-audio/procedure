// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'endpoint.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$EndpointType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() float,
    required TResult Function() int,
    required TResult Function() bool,
    required TResult Function() void_,
    required TResult Function(String field0) object,
    required TResult Function() unsupported,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? float,
    TResult? Function()? int,
    TResult? Function()? bool,
    TResult? Function()? void_,
    TResult? Function(String field0)? object,
    TResult? Function()? unsupported,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? float,
    TResult Function()? int,
    TResult Function()? bool,
    TResult Function()? void_,
    TResult Function(String field0)? object,
    TResult Function()? unsupported,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndpointType_Float value) float,
    required TResult Function(EndpointType_Int value) int,
    required TResult Function(EndpointType_Bool value) bool,
    required TResult Function(EndpointType_Void value) void_,
    required TResult Function(EndpointType_Object value) object,
    required TResult Function(EndpointType_Unsupported value) unsupported,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndpointType_Float value)? float,
    TResult? Function(EndpointType_Int value)? int,
    TResult? Function(EndpointType_Bool value)? bool,
    TResult? Function(EndpointType_Void value)? void_,
    TResult? Function(EndpointType_Object value)? object,
    TResult? Function(EndpointType_Unsupported value)? unsupported,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndpointType_Float value)? float,
    TResult Function(EndpointType_Int value)? int,
    TResult Function(EndpointType_Bool value)? bool,
    TResult Function(EndpointType_Void value)? void_,
    TResult Function(EndpointType_Object value)? object,
    TResult Function(EndpointType_Unsupported value)? unsupported,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EndpointTypeCopyWith<$Res> {
  factory $EndpointTypeCopyWith(
          EndpointType value, $Res Function(EndpointType) then) =
      _$EndpointTypeCopyWithImpl<$Res, EndpointType>;
}

/// @nodoc
class _$EndpointTypeCopyWithImpl<$Res, $Val extends EndpointType>
    implements $EndpointTypeCopyWith<$Res> {
  _$EndpointTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EndpointType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$EndpointType_FloatImplCopyWith<$Res> {
  factory _$$EndpointType_FloatImplCopyWith(_$EndpointType_FloatImpl value,
          $Res Function(_$EndpointType_FloatImpl) then) =
      __$$EndpointType_FloatImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EndpointType_FloatImplCopyWithImpl<$Res>
    extends _$EndpointTypeCopyWithImpl<$Res, _$EndpointType_FloatImpl>
    implements _$$EndpointType_FloatImplCopyWith<$Res> {
  __$$EndpointType_FloatImplCopyWithImpl(_$EndpointType_FloatImpl _value,
      $Res Function(_$EndpointType_FloatImpl) _then)
      : super(_value, _then);

  /// Create a copy of EndpointType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EndpointType_FloatImpl extends EndpointType_Float {
  const _$EndpointType_FloatImpl() : super._();

  @override
  String toString() {
    return 'EndpointType.float()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EndpointType_FloatImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() float,
    required TResult Function() int,
    required TResult Function() bool,
    required TResult Function() void_,
    required TResult Function(String field0) object,
    required TResult Function() unsupported,
  }) {
    return float();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? float,
    TResult? Function()? int,
    TResult? Function()? bool,
    TResult? Function()? void_,
    TResult? Function(String field0)? object,
    TResult? Function()? unsupported,
  }) {
    return float?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? float,
    TResult Function()? int,
    TResult Function()? bool,
    TResult Function()? void_,
    TResult Function(String field0)? object,
    TResult Function()? unsupported,
    required TResult orElse(),
  }) {
    if (float != null) {
      return float();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndpointType_Float value) float,
    required TResult Function(EndpointType_Int value) int,
    required TResult Function(EndpointType_Bool value) bool,
    required TResult Function(EndpointType_Void value) void_,
    required TResult Function(EndpointType_Object value) object,
    required TResult Function(EndpointType_Unsupported value) unsupported,
  }) {
    return float(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndpointType_Float value)? float,
    TResult? Function(EndpointType_Int value)? int,
    TResult? Function(EndpointType_Bool value)? bool,
    TResult? Function(EndpointType_Void value)? void_,
    TResult? Function(EndpointType_Object value)? object,
    TResult? Function(EndpointType_Unsupported value)? unsupported,
  }) {
    return float?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndpointType_Float value)? float,
    TResult Function(EndpointType_Int value)? int,
    TResult Function(EndpointType_Bool value)? bool,
    TResult Function(EndpointType_Void value)? void_,
    TResult Function(EndpointType_Object value)? object,
    TResult Function(EndpointType_Unsupported value)? unsupported,
    required TResult orElse(),
  }) {
    if (float != null) {
      return float(this);
    }
    return orElse();
  }
}

abstract class EndpointType_Float extends EndpointType {
  const factory EndpointType_Float() = _$EndpointType_FloatImpl;
  const EndpointType_Float._() : super._();
}

/// @nodoc
abstract class _$$EndpointType_IntImplCopyWith<$Res> {
  factory _$$EndpointType_IntImplCopyWith(_$EndpointType_IntImpl value,
          $Res Function(_$EndpointType_IntImpl) then) =
      __$$EndpointType_IntImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EndpointType_IntImplCopyWithImpl<$Res>
    extends _$EndpointTypeCopyWithImpl<$Res, _$EndpointType_IntImpl>
    implements _$$EndpointType_IntImplCopyWith<$Res> {
  __$$EndpointType_IntImplCopyWithImpl(_$EndpointType_IntImpl _value,
      $Res Function(_$EndpointType_IntImpl) _then)
      : super(_value, _then);

  /// Create a copy of EndpointType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EndpointType_IntImpl extends EndpointType_Int {
  const _$EndpointType_IntImpl() : super._();

  @override
  String toString() {
    return 'EndpointType.int()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EndpointType_IntImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() float,
    required TResult Function() int,
    required TResult Function() bool,
    required TResult Function() void_,
    required TResult Function(String field0) object,
    required TResult Function() unsupported,
  }) {
    return int();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? float,
    TResult? Function()? int,
    TResult? Function()? bool,
    TResult? Function()? void_,
    TResult? Function(String field0)? object,
    TResult? Function()? unsupported,
  }) {
    return int?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? float,
    TResult Function()? int,
    TResult Function()? bool,
    TResult Function()? void_,
    TResult Function(String field0)? object,
    TResult Function()? unsupported,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndpointType_Float value) float,
    required TResult Function(EndpointType_Int value) int,
    required TResult Function(EndpointType_Bool value) bool,
    required TResult Function(EndpointType_Void value) void_,
    required TResult Function(EndpointType_Object value) object,
    required TResult Function(EndpointType_Unsupported value) unsupported,
  }) {
    return int(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndpointType_Float value)? float,
    TResult? Function(EndpointType_Int value)? int,
    TResult? Function(EndpointType_Bool value)? bool,
    TResult? Function(EndpointType_Void value)? void_,
    TResult? Function(EndpointType_Object value)? object,
    TResult? Function(EndpointType_Unsupported value)? unsupported,
  }) {
    return int?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndpointType_Float value)? float,
    TResult Function(EndpointType_Int value)? int,
    TResult Function(EndpointType_Bool value)? bool,
    TResult Function(EndpointType_Void value)? void_,
    TResult Function(EndpointType_Object value)? object,
    TResult Function(EndpointType_Unsupported value)? unsupported,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int(this);
    }
    return orElse();
  }
}

abstract class EndpointType_Int extends EndpointType {
  const factory EndpointType_Int() = _$EndpointType_IntImpl;
  const EndpointType_Int._() : super._();
}

/// @nodoc
abstract class _$$EndpointType_BoolImplCopyWith<$Res> {
  factory _$$EndpointType_BoolImplCopyWith(_$EndpointType_BoolImpl value,
          $Res Function(_$EndpointType_BoolImpl) then) =
      __$$EndpointType_BoolImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EndpointType_BoolImplCopyWithImpl<$Res>
    extends _$EndpointTypeCopyWithImpl<$Res, _$EndpointType_BoolImpl>
    implements _$$EndpointType_BoolImplCopyWith<$Res> {
  __$$EndpointType_BoolImplCopyWithImpl(_$EndpointType_BoolImpl _value,
      $Res Function(_$EndpointType_BoolImpl) _then)
      : super(_value, _then);

  /// Create a copy of EndpointType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EndpointType_BoolImpl extends EndpointType_Bool {
  const _$EndpointType_BoolImpl() : super._();

  @override
  String toString() {
    return 'EndpointType.bool()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EndpointType_BoolImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() float,
    required TResult Function() int,
    required TResult Function() bool,
    required TResult Function() void_,
    required TResult Function(String field0) object,
    required TResult Function() unsupported,
  }) {
    return bool();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? float,
    TResult? Function()? int,
    TResult? Function()? bool,
    TResult? Function()? void_,
    TResult? Function(String field0)? object,
    TResult? Function()? unsupported,
  }) {
    return bool?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? float,
    TResult Function()? int,
    TResult Function()? bool,
    TResult Function()? void_,
    TResult Function(String field0)? object,
    TResult Function()? unsupported,
    required TResult orElse(),
  }) {
    if (bool != null) {
      return bool();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndpointType_Float value) float,
    required TResult Function(EndpointType_Int value) int,
    required TResult Function(EndpointType_Bool value) bool,
    required TResult Function(EndpointType_Void value) void_,
    required TResult Function(EndpointType_Object value) object,
    required TResult Function(EndpointType_Unsupported value) unsupported,
  }) {
    return bool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndpointType_Float value)? float,
    TResult? Function(EndpointType_Int value)? int,
    TResult? Function(EndpointType_Bool value)? bool,
    TResult? Function(EndpointType_Void value)? void_,
    TResult? Function(EndpointType_Object value)? object,
    TResult? Function(EndpointType_Unsupported value)? unsupported,
  }) {
    return bool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndpointType_Float value)? float,
    TResult Function(EndpointType_Int value)? int,
    TResult Function(EndpointType_Bool value)? bool,
    TResult Function(EndpointType_Void value)? void_,
    TResult Function(EndpointType_Object value)? object,
    TResult Function(EndpointType_Unsupported value)? unsupported,
    required TResult orElse(),
  }) {
    if (bool != null) {
      return bool(this);
    }
    return orElse();
  }
}

abstract class EndpointType_Bool extends EndpointType {
  const factory EndpointType_Bool() = _$EndpointType_BoolImpl;
  const EndpointType_Bool._() : super._();
}

/// @nodoc
abstract class _$$EndpointType_VoidImplCopyWith<$Res> {
  factory _$$EndpointType_VoidImplCopyWith(_$EndpointType_VoidImpl value,
          $Res Function(_$EndpointType_VoidImpl) then) =
      __$$EndpointType_VoidImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EndpointType_VoidImplCopyWithImpl<$Res>
    extends _$EndpointTypeCopyWithImpl<$Res, _$EndpointType_VoidImpl>
    implements _$$EndpointType_VoidImplCopyWith<$Res> {
  __$$EndpointType_VoidImplCopyWithImpl(_$EndpointType_VoidImpl _value,
      $Res Function(_$EndpointType_VoidImpl) _then)
      : super(_value, _then);

  /// Create a copy of EndpointType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EndpointType_VoidImpl extends EndpointType_Void {
  const _$EndpointType_VoidImpl() : super._();

  @override
  String toString() {
    return 'EndpointType.void_()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EndpointType_VoidImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() float,
    required TResult Function() int,
    required TResult Function() bool,
    required TResult Function() void_,
    required TResult Function(String field0) object,
    required TResult Function() unsupported,
  }) {
    return void_();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? float,
    TResult? Function()? int,
    TResult? Function()? bool,
    TResult? Function()? void_,
    TResult? Function(String field0)? object,
    TResult? Function()? unsupported,
  }) {
    return void_?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? float,
    TResult Function()? int,
    TResult Function()? bool,
    TResult Function()? void_,
    TResult Function(String field0)? object,
    TResult Function()? unsupported,
    required TResult orElse(),
  }) {
    if (void_ != null) {
      return void_();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndpointType_Float value) float,
    required TResult Function(EndpointType_Int value) int,
    required TResult Function(EndpointType_Bool value) bool,
    required TResult Function(EndpointType_Void value) void_,
    required TResult Function(EndpointType_Object value) object,
    required TResult Function(EndpointType_Unsupported value) unsupported,
  }) {
    return void_(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndpointType_Float value)? float,
    TResult? Function(EndpointType_Int value)? int,
    TResult? Function(EndpointType_Bool value)? bool,
    TResult? Function(EndpointType_Void value)? void_,
    TResult? Function(EndpointType_Object value)? object,
    TResult? Function(EndpointType_Unsupported value)? unsupported,
  }) {
    return void_?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndpointType_Float value)? float,
    TResult Function(EndpointType_Int value)? int,
    TResult Function(EndpointType_Bool value)? bool,
    TResult Function(EndpointType_Void value)? void_,
    TResult Function(EndpointType_Object value)? object,
    TResult Function(EndpointType_Unsupported value)? unsupported,
    required TResult orElse(),
  }) {
    if (void_ != null) {
      return void_(this);
    }
    return orElse();
  }
}

abstract class EndpointType_Void extends EndpointType {
  const factory EndpointType_Void() = _$EndpointType_VoidImpl;
  const EndpointType_Void._() : super._();
}

/// @nodoc
abstract class _$$EndpointType_ObjectImplCopyWith<$Res> {
  factory _$$EndpointType_ObjectImplCopyWith(_$EndpointType_ObjectImpl value,
          $Res Function(_$EndpointType_ObjectImpl) then) =
      __$$EndpointType_ObjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$EndpointType_ObjectImplCopyWithImpl<$Res>
    extends _$EndpointTypeCopyWithImpl<$Res, _$EndpointType_ObjectImpl>
    implements _$$EndpointType_ObjectImplCopyWith<$Res> {
  __$$EndpointType_ObjectImplCopyWithImpl(_$EndpointType_ObjectImpl _value,
      $Res Function(_$EndpointType_ObjectImpl) _then)
      : super(_value, _then);

  /// Create a copy of EndpointType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EndpointType_ObjectImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EndpointType_ObjectImpl extends EndpointType_Object {
  const _$EndpointType_ObjectImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'EndpointType.object(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EndpointType_ObjectImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of EndpointType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EndpointType_ObjectImplCopyWith<_$EndpointType_ObjectImpl> get copyWith =>
      __$$EndpointType_ObjectImplCopyWithImpl<_$EndpointType_ObjectImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() float,
    required TResult Function() int,
    required TResult Function() bool,
    required TResult Function() void_,
    required TResult Function(String field0) object,
    required TResult Function() unsupported,
  }) {
    return object(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? float,
    TResult? Function()? int,
    TResult? Function()? bool,
    TResult? Function()? void_,
    TResult? Function(String field0)? object,
    TResult? Function()? unsupported,
  }) {
    return object?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? float,
    TResult Function()? int,
    TResult Function()? bool,
    TResult Function()? void_,
    TResult Function(String field0)? object,
    TResult Function()? unsupported,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndpointType_Float value) float,
    required TResult Function(EndpointType_Int value) int,
    required TResult Function(EndpointType_Bool value) bool,
    required TResult Function(EndpointType_Void value) void_,
    required TResult Function(EndpointType_Object value) object,
    required TResult Function(EndpointType_Unsupported value) unsupported,
  }) {
    return object(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndpointType_Float value)? float,
    TResult? Function(EndpointType_Int value)? int,
    TResult? Function(EndpointType_Bool value)? bool,
    TResult? Function(EndpointType_Void value)? void_,
    TResult? Function(EndpointType_Object value)? object,
    TResult? Function(EndpointType_Unsupported value)? unsupported,
  }) {
    return object?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndpointType_Float value)? float,
    TResult Function(EndpointType_Int value)? int,
    TResult Function(EndpointType_Bool value)? bool,
    TResult Function(EndpointType_Void value)? void_,
    TResult Function(EndpointType_Object value)? object,
    TResult Function(EndpointType_Unsupported value)? unsupported,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(this);
    }
    return orElse();
  }
}

abstract class EndpointType_Object extends EndpointType {
  const factory EndpointType_Object(final String field0) =
      _$EndpointType_ObjectImpl;
  const EndpointType_Object._() : super._();

  String get field0;

  /// Create a copy of EndpointType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EndpointType_ObjectImplCopyWith<_$EndpointType_ObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EndpointType_UnsupportedImplCopyWith<$Res> {
  factory _$$EndpointType_UnsupportedImplCopyWith(
          _$EndpointType_UnsupportedImpl value,
          $Res Function(_$EndpointType_UnsupportedImpl) then) =
      __$$EndpointType_UnsupportedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EndpointType_UnsupportedImplCopyWithImpl<$Res>
    extends _$EndpointTypeCopyWithImpl<$Res, _$EndpointType_UnsupportedImpl>
    implements _$$EndpointType_UnsupportedImplCopyWith<$Res> {
  __$$EndpointType_UnsupportedImplCopyWithImpl(
      _$EndpointType_UnsupportedImpl _value,
      $Res Function(_$EndpointType_UnsupportedImpl) _then)
      : super(_value, _then);

  /// Create a copy of EndpointType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EndpointType_UnsupportedImpl extends EndpointType_Unsupported {
  const _$EndpointType_UnsupportedImpl() : super._();

  @override
  String toString() {
    return 'EndpointType.unsupported()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EndpointType_UnsupportedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() float,
    required TResult Function() int,
    required TResult Function() bool,
    required TResult Function() void_,
    required TResult Function(String field0) object,
    required TResult Function() unsupported,
  }) {
    return unsupported();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? float,
    TResult? Function()? int,
    TResult? Function()? bool,
    TResult? Function()? void_,
    TResult? Function(String field0)? object,
    TResult? Function()? unsupported,
  }) {
    return unsupported?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? float,
    TResult Function()? int,
    TResult Function()? bool,
    TResult Function()? void_,
    TResult Function(String field0)? object,
    TResult Function()? unsupported,
    required TResult orElse(),
  }) {
    if (unsupported != null) {
      return unsupported();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndpointType_Float value) float,
    required TResult Function(EndpointType_Int value) int,
    required TResult Function(EndpointType_Bool value) bool,
    required TResult Function(EndpointType_Void value) void_,
    required TResult Function(EndpointType_Object value) object,
    required TResult Function(EndpointType_Unsupported value) unsupported,
  }) {
    return unsupported(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndpointType_Float value)? float,
    TResult? Function(EndpointType_Int value)? int,
    TResult? Function(EndpointType_Bool value)? bool,
    TResult? Function(EndpointType_Void value)? void_,
    TResult? Function(EndpointType_Object value)? object,
    TResult? Function(EndpointType_Unsupported value)? unsupported,
  }) {
    return unsupported?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndpointType_Float value)? float,
    TResult Function(EndpointType_Int value)? int,
    TResult Function(EndpointType_Bool value)? bool,
    TResult Function(EndpointType_Void value)? void_,
    TResult Function(EndpointType_Object value)? object,
    TResult Function(EndpointType_Unsupported value)? unsupported,
    required TResult orElse(),
  }) {
    if (unsupported != null) {
      return unsupported(this);
    }
    return orElse();
  }
}

abstract class EndpointType_Unsupported extends EndpointType {
  const factory EndpointType_Unsupported() = _$EndpointType_UnsupportedImpl;
  const EndpointType_Unsupported._() : super._();
}
